#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>


#define POOL_SIZE 4096
#define ALIGNMENT 8
#define ALIGN(sz)   (((sz) + (ALIGNMENT-1)) & ~(ALIGNMENT-1))

typedef struct MemoryBlock {
    size_t size;                 // payload size (aligned, excludes header)
    int    is_free;              // 1 free, 0 allocated
    struct MemoryBlock* next;    // next block (address order)
    struct MemoryBlock* prev;    // prev block (address order)
    void* addr_in_pool;          // pointer to memory in the pool 
} MemoryBlock;

typedef struct {
    void*  pool_start;
    size_t total_size;
    size_t free_size;            // sum of sizes of all FREE payloads
    MemoryBlock* all_list;      // head of all blocks (address-sorted)
    int    total_blocks;         // free + allocated
    int    free_blocks;          // count of free nodes in all_list
} MemoryPool;

static MemoryPool g_pool = {0};

/* ---------------- Debugging headers ---------------- */
void pool_debug(void);

int pool_init(void) {
    g_pool.pool_start = malloc(POOL_SIZE);
    if (g_pool.pool_start == NULL) {
        fprintf(stderr, "Failed to allocate memory pool\n");
        return -1;
    }
    
    g_pool.total_size = POOL_SIZE;
    g_pool.free_size = POOL_SIZE;
    
// ChatGPT created: Creates the initial free block for the pool, allocating its header separately.
// Initializes size, free status, and links, ensuring proper pool startup bookkeeping.
    MemoryBlock* initial_block = (MemoryBlock*)malloc(sizeof(MemoryBlock));
    if (initial_block == NULL) {
        free(g_pool.pool_start);
        fprintf(stderr, "Failed to allocate initial block\n");
        return -1;
    }
    
    initial_block->size = POOL_SIZE;
    initial_block->is_free = 1;
    initial_block->next = NULL;
    initial_block->prev = NULL;
    initial_block->addr_in_pool = g_pool.pool_start;
    
    g_pool.all_list = initial_block;
    g_pool.total_blocks = 1;
    g_pool.free_blocks = 1;
    
    return 0;
}

void pool_cleanup(void) {
    if (g_pool.pool_start != NULL) {
        free(g_pool.pool_start);
    }
    
    MemoryBlock* cur = g_pool.all_list;
    while (cur != NULL) {
        MemoryBlock* next = cur->next;
        free(cur);
        cur = next;
    }
    
    memset(&g_pool, 0, sizeof(g_pool));
    
    g_pool.all_list = NULL;
    g_pool.total_blocks = 0;
    g_pool.free_blocks = 0;
}

MemoryBlock* find_free_block(size_t size) {
    // First-fit strategy: find the first free block with size >= requested size. Generated by Claude.
    MemoryBlock* cur = g_pool.all_list;
    while (cur != NULL) {
        if (cur->is_free && cur->size >= size) {
            return cur;
        }
        cur = cur->next;
    }
    return NULL;
}

void add_to_list(MemoryBlock* existingblock, MemoryBlock* newblock) {
    newblock->prev = existingblock;
    newblock->next = existingblock->next;
    
    if (existingblock->next != NULL) {
        existingblock->next->prev = newblock;
    }
    
    existingblock->next = newblock;
    g_pool.total_blocks++;
}

void split_block(MemoryBlock* block, size_t size) {
    // Calculate leftover space.  
    size_t leftover = block->size - size;
    
    // Only split if there's enough leftover space to be meaningful. 
    if (leftover >= ALIGNMENT) {
        MemoryBlock* new_block = (MemoryBlock*)malloc(sizeof(MemoryBlock));
        if (new_block == NULL) {
            return;
        }
        
        new_block->size = leftover;
        new_block->is_free = 1;
        new_block->addr_in_pool = (char*)block->addr_in_pool + size;
        
        add_to_list(block, new_block);
        
        block->size = size;
        
        g_pool.free_blocks++;  
    }
}

void remove_from_list(MemoryBlock* block) {
    if (block->prev != NULL) {
        block->prev->next = block->next;
    } else {
        g_pool.all_list = block->next;
    }
    
// Safely unlinks a block from the doubly linked list and updates pool counters.
// Ensures both forward and backward pointers remain consistent after removal.
    if (block->next != NULL) {
        block->next->prev = block->prev;
    }
    
    // Update counters(Claude)
    g_pool.total_blocks--;
    if (block->is_free) {
        g_pool.free_blocks--;
    }
}

void coalesce_blocks(void) {
    MemoryBlock* cur = g_pool.all_list;
    
    while (cur != NULL && cur->next != NULL) {
        MemoryBlock* nxt = cur->next;
        
        // Check if both blocks are free and physically adjacent. 
        if (cur->is_free && nxt->is_free) {
            void* cur_end = (char*)cur->addr_in_pool + cur->size;
            if (cur_end == nxt->addr_in_pool) {
                cur->size += nxt->size;
                
                remove_from_list(nxt);
                
                free(nxt);
                
                // Don't advance cur; check again for more adjacent blocks. 
                continue;
            }
        }
        
        cur = cur->next;
    }
}

void* pool_malloc(size_t size) {
    if (size == 0) {
        return NULL;
    }
    
    size_t aligned_size = ALIGN(size);
    
    MemoryBlock* block = find_free_block(aligned_size);
    if (block == NULL) {
        return NULL;  // No suitable block found
    }
    
    split_block(block, aligned_size);
    
    block->is_free = 0;
    
    g_pool.free_blocks--;
    g_pool.free_size -= block->size;
    
    return block->addr_in_pool;
}

void pool_free(void* ptr) {
    if (ptr == NULL) {
        return;
    }
    
    MemoryBlock* block = NULL;
    MemoryBlock* cur = g_pool.all_list;
    
    while (cur != NULL) {
        if (cur->addr_in_pool == ptr) {
            block = cur;
            break;
        }
        cur = cur->next;
    }
    
    if (block == NULL) {
        fprintf(stderr, "Error: pointer %p not found in pool\n", ptr);
        return;
    }
    
    // 3) Check for double free 
    if (block->is_free) {
        fprintf(stderr, "Error: double free detected for pointer %p\n", ptr);
        return;
    }
        block->is_free = 1;
    
    g_pool.free_blocks++;
    g_pool.free_size += block->size;
    
    coalesce_blocks();
}

/* ---------------- Debugging helpers ---------------- */
void pool_debug(void) {
    printf("\n*****\nDEBUG: ");
    if (g_pool.all_list == NULL) {
        printf("  <empty list>\n");
        printf("*****\n\n");
        return;
    } else {
        printf("Details of all blocks:\n");
        int counter = 1;
        for (MemoryBlock* cur = g_pool.all_list; cur; cur = cur->next) {
            printf("  Block %d at %p: size=%zu, is_free=%d, addr_in_pool=%p, next=%p, prev=%p\n",
                counter++, (void*)cur, cur->size, cur->is_free, cur->addr_in_pool, (void*)cur->next, (void*)cur->prev);
        }
        printf("*****\n\n");
    }
}

/* ---------------- Implemented: pool_stats ---------------- */
void pool_stats(void) {
    size_t largest_free = 0, free_count = 0, free_bytes = 0;
    for (MemoryBlock* cur = g_pool.all_list; cur; cur = cur->next) {
        if (cur->is_free) {
            free_count++;
            free_bytes += cur->size;
            if (cur->size > largest_free) largest_free = cur->size;
        }
    }
    // Trust g_pool.free_size if maintained; recompute if zeroed.
    if (g_pool.free_size == 0 && free_bytes) g_pool.free_size = free_bytes;

    double frag = 0.0;
    if (g_pool.free_size > 0) {
        frag = 1.0 - (double)largest_free / (double)g_pool.free_size;
        if (frag < 0.0) frag = 0.0;   // guard against bookkeeping bugs
        if (frag > 1.0) frag = 1.0;
    }

    printf("=== Memory Pool Statistics ===\n");
    printf("Total pool size : %zu bytes\n", g_pool.total_size);
    printf("Free memory     : %zu bytes\n", g_pool.free_size);
    printf("Total blocks    : %d\n", g_pool.total_blocks);
    printf("Free blocks     : %d (scanned=%zu)\n", g_pool.free_blocks, free_count);
    printf("Largest free    : %zu bytes\n", largest_free);
    printf("Fragmentation   : %.1f%%\n", frag * 100.0);
    printf("==============================\n");
}

/* ---------------- Test harness: script runner --- */
#define MAX_IDS 1024
typedef struct { char name[32]; void* ptr; } Slot;
static Slot g_slots[MAX_IDS];

static int find_slot(const char* name) {
    for (int i = 0; i < MAX_IDS; ++i)
        if (g_slots[i].name[0] && strcmp(g_slots[i].name, name) == 0) return i;
    return -1;
}
static int ensure_slot(const char* name) {
    int idx = find_slot(name);
    if (idx >= 0) return idx;
    for (int i = 0; i < MAX_IDS; ++i)
        if (!g_slots[i].name[0]) { strncpy(g_slots[i].name, name, sizeof(g_slots[i].name)-1); return i; }
    return -1;
}

static void trim_newline(char* s){ size_t n=strlen(s); if(n&&s[n-1]=='\n') s[n-1]=0; }

static void run_script(FILE* fp) {
    char line[256]; int line_no = 0;
    while (fgets(line, sizeof line, fp)) {
        line_no++; trim_newline(line);
        char* p = line; while (*p && isspace((unsigned char)*p)) p++;
        if (*p == 0 || *p == '#') continue;

        char cmd[32], a[64]; size_t size = 0; a[0] = 0;
        if (sscanf(p, "%31s %63s %zu", cmd, a, &size) < 1) continue;

        if (strcmp(cmd, "INIT") == 0) {
            if (pool_init() != 0) { fprintf(stderr, "INIT failed\n"); return; }
        } else if (strcmp(cmd, "MALLOC") == 0) {
            if (!a[0] || size == 0) { fprintf(stderr, "Line %d: MALLOC <id> <size>\n", line_no); continue; }
            int idx = ensure_slot(a); if (idx < 0) { fprintf(stderr, "Line %d: ID table full\n", line_no); continue; }
            g_slots[idx].ptr = pool_malloc(size);
            printf("MALLOC %s %zu\n", a, size);
        } else if (strcmp(cmd, "FREE") == 0) {
            if (!a[0]) { fprintf(stderr, "Line %d: FREE <id>\n", line_no); continue; }
            int idx = find_slot(a);
            if (idx < 0 || !g_slots[idx].ptr) { fprintf(stderr, "Line %d: unknown id '%s'\n", line_no, a); continue; }
            printf("FREE %s\n", a);
            pool_free(g_slots[idx].ptr); g_slots[idx].ptr = NULL;
        } else if (strcmp(cmd, "STATS") == 0) {
            pool_stats();
        } else if (strcmp(cmd, "DEBUG") == 0) {
            pool_debug();
        } else if (strcmp(cmd, "COALESCE") == 0) {
            coalesce_blocks();
        } else if (strcmp(cmd, "CLEANUP") == 0) {
            pool_cleanup();
        } else if (strcmp(cmd, "QUIT") == 0) {
            break;
        } else {
            fprintf(stderr, "Line %d: unknown command '%s'\n", line_no, cmd);
        }
    }
}

/* ---------------- main ---------------- */
int main(int argc, char** argv) {
    char filename[256];
    
    // Prompt user for input filename
    printf("Enter the name of the commands file: \n");
    fflush(stdout);  // Ensure prompt is displayed immediately
    
    if (!fgets(filename, sizeof(filename), stdin)) {
        fprintf(stderr, "Error reading filename\n");
        return 1;
    }
    
    // Remove newline character if present
    size_t len = strlen(filename);
    if (len > 0 && filename[len-1] == '\n') {
        filename[len-1] = '\0';
    }
    
    // Check if filename is empty
    if (strlen(filename) == 0) {
        fprintf(stderr, "No filename provided\n");
        return 1;
    }
    
    FILE* fp = fopen(filename, "r");
    if (!fp) { 
        perror(filename); 
        return 1; 
    }
    
    run_script(fp);
    fclose(fp);
    if (g_pool.pool_start) pool_cleanup(); // safety
    return 0;
}
